\documentclass{article}
\usepackage[hidelinks]{hyperref}
\usepackage{todonotes}
\setuptodonotes{inline}
\setlength{\parindent}{0em}
\setlength{\parskip}{1pt}

\title{Danaswap specification}
\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introduction}

This is an early draft of the DanaSwap spec. The document starts with the
``Interactions'' section, defining what the protocol should be able to do. Next
come the ``Acceptance criteria'', containing descriptions of requirements we
have on those interactions. Any important implementation details are detailed in
the ``Implementation Details'' section after that. Finally, the ``Tests''
section provides an exhaustive list of the way we plan to falsify whether we
should deploy.  \\

Note: Every subsection that contain `TBD' (``to be determined'') in the title is
not fully agreed upon yet. Every subsection containing `TBC' (``to be
confirmed'', by Ryan) in the title is mostly agreed upon, but still requires
last confirmation. The other sections are considered law.

\section{Interactions}

\subsection*{Initialize pool with liquidity}

This should create a pool with some initial balance for both its assets, giving
the creator the appropriate number of liquidity tokens. Note that the `admin'
user is determined by a set of three pre-determined keys, which are hardcoded
into the script. Anyone can initialize a pool through the UX. \\

Each pool only contains two assets and has its own liquidity token. Once a pool
is created between assets A and B, the UI no longer allows to create a pool
between these assets.

\subsection*{Swap}

A user can exchange tokens at a rate defined by the constant product invariant,
$x \cdot y = k^2$. The user gets $\Delta y$ in return for paying $\Delta x$, where
$(x + \Delta x) \cdot (y - \Delta y) \geq k^2$, minus the liquidity fee and admin
fee.

Note: $k$ should not be computed on chain, everything can be done in terms of $k^2$

\subsection*{Add liquidity}

A user should be able to add liquidity to a given pool, and mint that pool’s
liquidity tokens in return. The number of liquidity tokens minted is
proportional to the growth of the pool. Specifically, this means that $\Delta k
/ k \leq \Delta L / L$, where $k$ is the parameter in the equation $x \cdot y = k^2$,
$L$ is the number of liquidity tokens minted and $\Delta L$ is the number of
liquidity tokens minted again.

Note: Here also $k$ should not be computed on chain, we can use the equivalent constraint
$(\Delta k / k)^2  \leq (\Delta L / L)^2$ which should avoid the square root.

\subsection*{Withdraw liquidity}

A user who owns liquidity tokens for a given pool, can burn them in exchange for
getting back a proportional part of the assets left in the pool.

\subsection*{Withdraw liquidity in one asset class}

A user who owns liquidity tokens for a given pool, can choose to withdraw
liquidity in one token, again following the equation $x \cdot y = k^2$. This
endpoint charges the liquidity fee and admin fee.

\subsection*{Kill pool (admin)}

Each pool has a kill switch, which disallows any transaction with the pool
except for the regular ``Withdraw liquidity'' endpoint. Even the ``Withdraw
liquidity in one asset class'' endpoint is no longer allowed. Only the admin
user can kill a pool.

\subsection*{Collect admin fees (admin)}

the admin user can collect the admin fees from a pool which have aggregated from
swaps and single-asset-class withdrawals.

\subsection*{List pools}

The UX show all Danaswap pools in existence.

\subsection*{Show pool info}

For each Danasawp pool in existence, the UX shows the asset amounts in the pool,
total amount of liquidity tokens minted, exchange rates and price of the
liquidity token.

\section{Acceptance criteria}

\begin{itemize}
  \item When initializing a pool, no asset balances can be $0$
  \item Once a pool is initialized between assets $A$ and $B$, the UX disallows
    creating another pool between the same assets
  \item Any user can initialize a pool
  \item The admin user is independent of who created the pool
  \item The admin user can kill pools
  \item Non-admin users cannot kill pools
  \item A pool that is killed, only supports the ``Withdraw liquidity'' endpoint
  \item Small swaps create low slippage
  \item If the balances of the two assets in a pool are roughly equal, their
    exchange rate is roughly $1$
  \item Swaps selling $A$ to the pool in exchange for $B$ increase the exchange
    rate $A \rightarrow B$ and decrease the exchange rate $B \rightarrow A$
  \item When performing a swap, the correct fee is paid
  \item Any user can add liquidity
  \item When adding liquidity, the user receives the correct number of liquidity
    tokens
  \item When withdrawing liquidity, the user receives the correct amount of
    assets
  \item When withdrawing liquidity in one asset class, the correct fee is paid
  \item When creating a new pool and then listing all existing pools, the new
    pool shows up
  \item Each pool is discoverable and traceable, as shown through its ``pool
    info''
  \item When showing a pool's info and then interacting with it (kill, swap, add
    liquidity, withdraw liquidity), the pool's info updates appropriately
  \item Each pool is verifiable, i.e. any pool which has been initialized
    appropriately is considered a legitimate pool and vice versa
\end{itemize}

\section{Implementation details}

This section discusses what we need in order to implement the interactions
mentioned above.

\todo{Write a summary that makes this easier to understand on the first reading}

The components we need:
\begin{itemize}
  \item DEX pools
  \item Pool identifying NFTs
  \item Liquidity tokens
\end{itemize}

The basic function of the protocol is to allow users to exchange
currencies for each other for a small fee.
Facilitating these exchanges requires liquidity so
the protocol needs to allow some users (liquidity providers)
to provide liquidity to the exchange, in exchange for doing so
the liquidity providers are compensated with a share of the fees.

The DEX pools store liquidity and allow users to exchange tokens
for a small fee.
The pool identifying NFTs allow for easy tracking of pools and
certify that each pool was opened legitimately.
The liquidity tokens represent ownership of a share of the liquidity
in a pool. They can be given to users in exchange for depositing liquidity
and then redeemed for that liquidity plus an appropriate share of the fees.

\subsection{Pool Addresses validator}

The pool addresses validator controls when pools can be spent.
It is therefore responsible for controlling swaps,
liquidity deposits and withdrawals, and pool termination.
It is also responsible for ensuring that
pool id tokens never leave its addresses
because they could then be used to open invalid pools.

To do this it enforces the following:
\begin{itemize}
	\item The input and output pools are valid
	\item The redeemer is valid
	\item When the redeemer action is Swap:
		\begin{itemize}
			\item The exchange invariant doesn't decrease
			\item The Admin fee is increased appropriately
			\item The Fee amount is left in the pool
			\item No liquidity tokens are minted
			\item The input and output pools are both live
		\end{itemize}
	\item When the redeemer action Liquidity
		\begin{itemize}
			\item The liquidity invariant $L^2/k^2$ is non decreasing
			\item Appropriate fees are paid
				\todo{how should fees work here?}
			\item The datum correctly reflects the change in issued liquidity
			\item If the "liveness" of the pool is not changed
			\item If the input pool is dead the issued liquidity decreases
		\end{itemize}
	\item When the redeemer action is Kill
		\begin{itemize}
			\item The admin signed the transaction
			\item Nothing else is changed in the pool
		\end{itemize}
\end{itemize}


\subsection{Pool id minting policy}

The pool id token is a token used to track pools
and to ensure that the pools protocol interacts with were opened legitimately.
The pool id token's minting policy is responsible for ensuring
that it is only minted as part of opening a valid vault.
To do so it should enforce all of the following:

\begin{itemize}
	\item The config utxo is valid
	\item Exactly one token is minted
	\item That token is sent to a pool
	\item The redeemer parses and provides a seed utxo
	\item The token name of the minted token is the hash of the seed utxo
	\item The seed utxo is spent in the transaction
	\item The transaction is signed by the admin keys
	\item The output pool datum is valid
	\item The datum correctly reflects the number of liquidity tokens being minted
	\item at least one liquidity token is being minted
	\item the initial invariant is not zero ie. some liquidity is provided in each token
	\todo{In the spec it says at most one pool per asset class pair
				AFAICT that adds a lot of complexity so I'm not sure it's worth it
		}
\end{itemize}

\section{Liquidity token minting policy}

The liquidity tokens are used to represent ownership of liquidity in a pool.
Their minting policy is responsible for ensuring that they are only minted
during liquidity interactions with a pool and during pool initializations.

Since the pools addresses validator and the pool id token minting policy
already enforce the logic regarding how much should be minted the liquidity
token minting policy doesn't have to do much. It just enforces the following:
\begin{itemize}
	\item Only one token name is being minted
	\item The redeemer is valid
		\begin{itemize}
			\item When the redeemer is Initialize: A pool id token with the same id is being minted
			\item When the redeemer is Pool: There is an input with a pool id token with the same id
		\end{itemize}
\end{itemize}

\subsection{Config utxo}

In this protocol some of the components need to know
each other's addresses and currency symbols.
In our case the graph of these dependencies is not acyclic
so to avoid circular hash dependencies a config utxo is needed.
Fortunately it is possible for the config utxo to be needed
only for the dependencies of the pool id token so it
only needs to be used when opening a vault.

The following dependencies are passed as parameters:
\begin{itemize}
	\item Pool addresses $\rightarrow$ Liquidity token
	\item Pool addresses $\rightarrow$ Pool id token
	\item Liquidity token $\rightarrow$ Pool id token
\end{itemize}
Importantly this is acyclic.


The following are read from the config utxo:
\begin{itemize}
	\item Pool id token $\rightarrow$ Pool addresses
	\item Pool id token $\rightarrow$ Liquidity token
\end{itemize}

\subsubsection{Config utxo addresses validator}

The config utxo needs an addresses where it can be used as a reference
input but can't be changed. Since use as a reference input doesn't
invoke a validator this validator can just always fail.

\subsubsection{Config utxo identifying NFT minting policy}

The config utxo also needs an NFT to distinguish it from any
invalid config utxos. This can just be a boiler plate NFT contract,
so we can use the one already in the CAT (Cardano App Template).


\section{Tests}

\todo{Off-chain tests check that what should work on-chain, does work}

\todo{Apropos-Tx???}

\subsection{Unit tests}

The following intended behaviors need to work:
\begin{itemize}
  \item Initializing a protocol and pool works
  \item queries accurately reflect how the pool was setup
  \item valid swaps work
  \item the queries correctly report which swaps would be valid
  \item queries accurately reflect the change from a swap
  \item valid liquidity changes work
  \item queries reflect the liquidity changes
  \item admin can kill a pool
  \item liquidity can be extracted from a dead pool
\end{itemize}

Nick's tests:
\begin{itemize}
  \item When adding liquidity, the number in the pool's datum representing the
    total amount of liquidity minted goes up by the correct amount
\end{itemize}

\subsection{Attacks}

The following attacks need to not work:
\begin{itemize}
  \item Get a pool authorization nft away from a pool (this should include tests at each type of interaction)
  \item non-admin kill a pool
  \item extract too much in an exchange
  \item over mint liquidity
  \item under burn liquidity
  \item burn the wrong pool’s liquidity token
  \item mint the wrong tools liquidity token
\end{itemize}

\end{document}
