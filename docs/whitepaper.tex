\documentclass{article}
\usepackage{hyperref}
\usepackage{todonotes}
\setuptodonotes{inline}
\setlength{\parindent}{0em}
\setlength{\parskip}{1pt}

\title{Danaswap specification}
\begin{document}

\maketitle

\begingroup
  \hypersetup{hidelinks}
  \tableofcontents
\endgroup
\newpage

\section{Introduction}

This is an early draft of the DanaSwap spec. The document starts with the
``Interactions'' section, defining what the protocol should be able to do. Next
come the ``Acceptance criteria'', containing descriptions of requirements we
have on those interactions. Any important implementation details are detailed in
the ``Implementation Details'' section after that. Finally, the ``Tests''
section provides an exhaustive list of the way we plan to falsify whether we
should deploy.  \\

Note: Every subsection that contain `TBD' (``to be determined'') in the title is
not fully agreed upon yet. Every subsection containing `TBC' (``to be
confirmed'', by Ryan) in the title is mostly agreed upon, but still requires
last confirmation. The other sections are considered law.

\section{Interactions}

\subsection*{Initialize pool with liquidity}

This should create a pool with some initial balance for both its assets, giving
the creator the appropriate number of liquidity tokens. Anyone can initialize a
pool through the UX. Each pool only contains two assets and has its own
liquidity token. Once a pool is created between assets A and B, the UI no longer
allows to create a pool between these assets. \\

Note that the `admin' user is determined not by who creates pools, but by a set
of three pre-determined public keys, which are hardcoded into the script.

\subsection*{Swap}

A user can exchange tokens at a rate defined by the constant product invariant,
$x \cdot y = k^2$. The user gets $\Delta y$ in return for paying $\Delta x$,
where $(x + \Delta x) \cdot (y - \Delta y) = k^2$, minus the liquidity fee and
admin fee. \\

Note: No square roots ever need to be computed on-chain, since it only needs to
verify what the off-chain code produced. This means that everything can be done
in terms of $k^2$ and $L^2$, without any reference to $k$ and $L$ directly. This
is the case across the entire protocol.

\subsection*{Add liquidity}

A user should be able to add liquidity to a given pool, and mint that poolâ€™s
liquidity tokens in return. The number of liquidity tokens minted is
proportional to the growth of the pool. Specifically, this means that $\Delta k
/ k = \Delta L / L$, where $k$ is the parameter in the equation $x \cdot y =
k^2$, $L$ is the number of liquidity tokens minted and $\Delta L$ is the number
of liquidity tokens minted again. \\

Note: Adding liquidity costs both admin and LP fees as well.

\todo{How does this work, exactly?}

\subsection*{Withdraw liquidity}

A user who owns liquidity tokens for a given pool, can burn them in exchange for
getting back a proportional part of the assets left in the pool.

\subsection*{Withdraw liquidity in one asset class}

A user who owns liquidity tokens for a given pool, can choose to withdraw
liquidity in one token, again following the equation $x \cdot y = k^2$. This
endpoint charges the liquidity fee and admin fee.

\todo{How does this work, exactly?}

\subsection*{Kill pool (admin)}

Each pool has a kill switch, which disallows any transaction with the pool
except for the regular ``Withdraw liquidity'' endpoint. Even the ``Withdraw
liquidity in one asset class'' endpoint is no longer allowed. Only the admin
user can kill a pool.

\subsection*{Collect admin fees (admin)}

The admin user can collect the admin fees from a pool which have aggregated from
swaps and single-asset-class withdrawals.

\subsection*{List pools}

The UX show all Danaswap pools in existence.

\subsection*{Show pool info}

For each Danaswap pool in existence, the UX shows the asset amounts in the pool,
total amount of liquidity tokens minted, exchange rates and price of the
liquidity token.

\section{Acceptance criteria}

\begin{itemize}
  \item When initializing a pool, no asset balances can be $0$
  \item Once a pool is initialized between assets $A$ and $B$, the UX disallows
    creating another pool between the same assets
  \item Any user can initialize a pool
  \item The admin user is independent of who created the pool
  \item The admin user can kill pools
  \item Non-admin users cannot kill pools
  \item A pool that is killed, only supports the ``Withdraw liquidity'' endpoint
  \item Small swaps create low slippage
  \item If the balances of the two assets in a pool are roughly equal, their
    exchange rate is roughly $1$
  \item Swaps selling $A$ to the pool in exchange for $B$ increase the exchange
    rate $A \rightarrow B$ and decrease the exchange rate $B \rightarrow A$
  \item When performing a swap, the correct fee is paid
  \item Any user can add liquidity
  \item When adding liquidity, the user receives the correct number of liquidity
    tokens
  \item When withdrawing liquidity, the user receives the correct amount of
    assets
  \item When withdrawing liquidity in one asset class, the correct fee is paid
  \item When creating a new pool and then listing all existing pools, the new
    pool shows up
  \item Each pool is discoverable and traceable, as shown through its ``pool
    info''
  \item When showing a pool's info and then interacting with it (kill, swap, add
    liquidity, withdraw liquidity), the pool's info updates appropriately
  \item Each pool is verifiable, i.e. any pool which has been initialized
    appropriately is considered a legitimate pool and vice versa
\end{itemize}

\section{Implementation details}

This section discusses what we need in order to implement the interactions
mentioned above. \\

The protocol consists of four parts. Three of them are very simple, while most
of the logic is in the central component: The pool validator script. \\

Firstly, in order to run a DEX based on an automated market model\footnote{
  The automated market model states that rather than having market makers and
  takers, such as is done in stock exchanges, the users will be liquidity
  providers (LPs) and traders. The LPs provide liquidity into a pool in exchange
  for a liquidity token, which is used as a `receipt' of the amount of liquidity
  they provided. Traders can then swap against the pool, according to an
  invariant equation. For example, the initial invariant equation used by
  Danaswap will be $x \cdot y = k^2$, where $L \sim k$. This means that the
  amount $\Delta y$ a trader gets in exchange for adding $\Delta x$ is such that
  $(x + \Delta x) \cdot (y - \Delta y) = k^2 = x \cdot y$. \\

  When providing liquidity, $x \rightarrow x'$ and $y \rightarrow y'$ has the
  effect that $k \rightarrow k'$. The number of liquidity tokens the LP
  receives, $\Delta L$, then follows the rule $\Delta L / L = \Delta k / k$.
}, we need a liquidity token to exist, with a minting policy linked to a
specific pool.
Secondly, as in the Cardano Application Template, we want each pool be
identified by an NFT minted through a specific minting policy. This allows
anyone to verify that a UTXO at the pool script address is valid, as well as to
trace each pool.
Finally, our protocol contains a number of cyclic dependencies between the
different scripts. In order to resolve this, we follow the Config UTXO pattern.

\subsection{Config UTXO}

As mentioned above, our protocol will contain cyclic dependencies between the
different scripts. Imagine we go about the situation naively, and we make each
script dependent on the others. Now the hash of each script is dependent on the
hash of the other scripts, which leads to a computationally very difficult
problem to resolve. Therefore, we propose to use a different solution: The
Config UTXO. \\

The idea is that a Config UTXO is built, identified by an NFT, which holds in
its datum the hashes of all the scripts involved in the protocol. Each script
can then refer to the hashes in the Config UTXO in order to verify the other
scripts. In our case, the Config UTXO will only contain an NFT (to identify
itself) and a datum with the pool ID minting policy hash, the liquidity token
minting policy hash, and the pool validator script address.

\subsection{Pool ID minting policy}

Each pool will be identified by an NFT. This allows anyone to verify that a UTXO
at the pool script address is valid, as well as tracing each pool. This
constitutes structurally the same minting policy as the one in
\href{https://github.com/ArdanaLabs/cardano-app-template/blob/master/onchain/src/HelloDiscovery.hs}{
  Hello Discovery}.
The only distinction with the Hello Discovery minting policy is that the Pool ID
policy will refer to the Danaswap Config UTXO.

\subsection{Liquidity token minting policy}

The liquidity token minting policy will allow any valid pool\footnote{
  A valid pool is any UTXO at the pool script address which holds an NFT minted
  by the Pool ID minting policy.
} to mint and burn its corresponding liquidity token. The liquidity token
minting policy knows which liquidity token belongs to which pool through the
Pool ID (NFT).

\subsection{DEX pool}

When initializing a pool, $k_0^2 = x_0 \cdot y_0$ where $x_0$ and $y_0$ are the
initial balances of asset classes $X$ and $Y$. The admin user receives $L_0 =
k_0$ liquidity tokens. \\

Each pool datum consists of a number of parts:
\begin{itemize}
  \item Admin fee
  \item Liquidity provider fee
  \item The amount in each asset class ($X$ and $Y$) of collected admin fee.
    These amounts are subtracted from the pool's balances in any calculations
    involving the invariant equation.
  \item The number of liquidity tokens ever minted (minus burned)
  \item A boolean representing the pool's kill switch
\end{itemize}

\subsection{Off-chain notes}

\todo{How to list the pools, and get the pool info?}

\subsection{Remarks}

\begin{itemize}
  \item The protocol involves a number of equations which must be verified
    on-chain. All on-chain code will exclusively use integers (representing e.g.
    ADA amounts in lovelace, rather than ADA). We must thus define the concept
    of the invariant equation equality a bit more subtly. We propose to do this
    by claiming that $x \cdot y = k^2 \Leftrightarrow (k-1)^2 < x \cdot y <
    (k+1)^2$.
\end{itemize}

\todo{Figure out how rounding should actually be handled, both on-chain and
off-chain.}

\section{Tests}

\todo{List off-chain tests.}

Note: The off-chain tests also check that the on-chain code allows valid
transactions.

\todo{Should we write Apropos-Tx tests?}

\subsection{Components}

Tests are broken down by the onchain component they test. Each test case implies an attempt 
and expected result when submitting a transaction. 

\subsubsection{Config UTxO tests}

\begin{itemize}
	\item When minting an NFT with the seed UTxO an an input, validation passes.
	\item When minting an NFT with the seed UTxO as a reference input, validation fails.
	\item When minting an NFT more than once, validation fails.
	\item When burning an NFT, validation fails.
\end{itemize}

\subsubsection{Config UTxO address test}

\begin{itemize}
	\item When spending the config UTxO, validation fails.
\end{itemize}

\subsubsection{Liquidity Token Minting Policy tests}

\begin{itemize}
	\item When minting $\sqrt{A_0B_0}$ liquidity tokens on pool open, validation passes.
	\item When minting a different pool's liquidity token on pool open, validation fails.
	\item When minting multiple liquidity token types on pool open, validation fails.                   
	\item When minting liquidity tokens for a different pool than the pool being spent, validation fails.
	\item When burning liquidity tokens from a different pool than the pool being spent, validation fails.
	\item When minting liquidity for a pool at an address that is not the Pool Address Validator, validation fails.
  \item Given a pool containing total issued liquidity tokens of quantity $t$ of $T$ and asset
  pair of quantities $a$ of $A$ and $b$ of $B$, when the user provides quantities $\Delta a$ and $\Delta b$
  and mints a quantity of liquidity tokens less than or equal to
  $T \cdot \frac{\sqrt{ (a + \Delta a) \cdot (b + \Delta b)} - \sqrt{a \cdot b}}{\sqrt{a \cdot b}}$
  , validation passes.
  \item Given a pool containing total issued liquidity tokens of quantity $t$ of $T$ and asset
    pair of quantities $a$ of $A$ and $b$ of $B$, when the user provides quantities $\Delta a$ and $\Delta b$
    and mints a quantity of liquidity tokens greater than 
    $T \cdot \frac{\sqrt{ (a + \Delta a) \cdot (b + \Delta b)} - \sqrt{a \cdot b}}{\sqrt{a \cdot b}}$
    , validation fails.
  \item Given a pool containing total issued liquidity tokens of quantity $t$ of $T$ and asset
    pair of quantities $a$ of $A$ and $b$ of $B$, when the user burns 
    their liquidity token quantity $\Delta t$ and receives a quantity of $A$ less than or equal to
    $ a \cdot \Delta t/t $ and quantity of $B$ less than or equal to $ a \cdot \delta t/t $  
    , validation passes.
  \item Given a pool containing total issued liquidity tokens of quantity $t$ of $T$ and asset
    pair of quantities $a$ of $A$ and $b$ of $B$, when the user burns 
    their liquidity token quantity $\Delta t$ and receives a quantity of $A$ greater than
    $ a \cdot \Delta t/t $ or (||) quantity of token $B$ greater than or equal to $ a \cdot \delta t/t $  
    , validation fails.  
\end{itemize}

\subsubsection{Pool ID Token Minting Policy tests}

\begin{itemize}
	\item Non admin can initialize a pool
	\item Can't under pay for liquidity on open
	\item Can't open pool with 0 liquidity
	\item Can't open pool with 0 of either exchange token
		%% This is sorta redundant cause the liquidity needs to be
		%% wrong or 0
	\item Invalid config utxo can't be used to open a pool
	\item Can't mint more than 1 token
	\item Can't send identifier token to non-pool address
	\item Can't mint without spending seed Tx
	\item Can't issue more liquidity than datum reflects
	\item Can't mint with liquidity not equal to the initial invariant
	\item Can't remove pool id from address during any type of transaction
	\item Can't kill a pool with a swap
	\item Can't kill a pool with a liquidity change
	\item Can't swap on a dead pool
	\item Can't add liquidity to a dead pool
\end{itemize}

\subsubsection{Pool Address Validator tests}

\begin{itemize}
	\item can perform valid swaps
	\item can't underpay for swaps
	\item can perform valid liquidity changes
	\item can't perform underpaid liquidity changes
	\item admin can kill a pool
	\item non-admin can't kill a pool
	\item admin can't over extract fees
	\item liquidity can be extracted from a dead pool
\end{itemize}

\subsubsection{Query tests}

The following intended behaviors need to work:
\begin{itemize}
	\item New pools show up in queries
	\item New invalid pools do not show up in queries
	\todo{Do we need to worry about a large number of invalid pools slowing down
	queries? If so should we add an interaction to remove them?}
	\item Queries accurately reflect how the pool was setup
	\item Queries accurately reflect the change from a swap
	\item Queries accurately reflect liquidity changes
	\item Queries accurately reflect pool kills
	\item A swap in the $A \rightarrow B$ direction increases the price of $B$
	\item Exchange rate query is accurate for small exchanges
\end{itemize}

Additional tests:
\begin{itemize}
	\item When adding liquidity, the number in the pool's datum representing the
    total amount of liquidity minted goes up by the correct amount
\end{itemize}

Note: We should improve on the template by making better tools for checking that tests fail for the right reason.

\end{document}
