\documentclass{article}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{graphicx}
\setuptodonotes{inline}
\setlength{\parindent}{0em}
\setlength{\parskip}{1pt}

\title{Danaswap specification}
\begin{document}

\maketitle

\begingroup
  \hypersetup{hidelinks}
  \tableofcontents
\endgroup
\newpage

\section{Introduction}

This is an early draft of the DanaSwap spec. The document starts with the
``Interactions'' section, defining what the protocol should be able to do. Next
come the ``Acceptance criteria'', containing descriptions of requirements we
have on those interactions. Any important implementation details are detailed in
the ``Implementation Details'' section after that. Finally, the ``Tests''
section provides an exhaustive list of the way we plan to falsify whether we
should deploy.  \\

Note: Every subsection that contain `TBD' (``to be determined'') in the title is
not fully agreed upon yet. Every subsection containing `TBC' (``to be
confirmed'', by Ryan) in the title is mostly agreed upon, but still requires
last confirmation. The other sections are considered law.

\section{Interactions}

\subsection*{Initialize pool with liquidity}

This should create a pool with some initial balance for both its assets, giving
the creator the appropriate number of liquidity tokens. Anyone can initialize a
pool through the UX. Each pool only contains two assets and has its own
liquidity token. Once a pool is created between assets A and B, the UI no longer
allows to create a pool between these assets. \\

Note that the `admin' user is determined not by who creates pools, but by a set
of three pre-determined public keys, which are hardcoded into the script.

\subsection*{Swap}

A user can exchange tokens at a rate defined by the constant product invariant,
$x \cdot y = k^2$. The user gets $\Delta y$ in return for paying $\Delta x$,
where $(x + \Delta x) \cdot (y - \Delta y) = k^2$, minus the liquidity fee and
admin fee. \\

Note: No square roots ever need to be computed on-chain, since it only needs to
verify what the off-chain code produced. This means that everything can be done
in terms of $k^2$ and $L^2$, without any reference to $k$ and $L$ directly. This
is the case across the entire protocol.

\subsection*{Add liquidity}

A user should be able to add liquidity to a given pool, and mint that poolâ€™s
liquidity tokens in return. The number of liquidity tokens minted is
proportional to the growth of the pool. Specifically, this means that $\Delta k
/ k = \Delta L / L$, where $k$ is the parameter in the equation $x \cdot y =
k^2$, $L$ is the number of liquidity tokens minted and $\Delta L$ is the number
of liquidity tokens minted again. \\

Note: Adding liquidity costs both admin and LP fees as well.

\todo{How does this work, exactly?}

\subsection*{Withdraw liquidity}

A user who owns liquidity tokens for a given pool, can burn them in exchange for
getting back a proportional part of the assets left in the pool.

\subsection*{Withdraw liquidity in one asset class}

A user who owns liquidity tokens for a given pool, can choose to withdraw
liquidity in one token, again following the equation $x \cdot y = k^2$. This
endpoint charges the liquidity fee and admin fee.

\todo{How does this work, exactly?}

\subsection*{Kill pool (admin)}

Each pool has a kill switch, which disallows any transaction with the pool
except for the regular ``Withdraw liquidity'' endpoint. Even the ``Withdraw
liquidity in one asset class'' endpoint is no longer allowed. Only the admin
user can kill a pool.

\subsection*{Collect admin fees (admin)}

The admin user can collect the admin fees from a pool which have aggregated from
swaps and single-asset-class withdrawals.

\subsection*{List pools}

The UX show all Danaswap pools in existence.

\subsection*{Show pool info}

For each Danaswap pool in existence, the UX shows the asset amounts in the pool,
total amount of liquidity tokens minted, exchange rates and price of the
liquidity token.

\section{Acceptance criteria}

\subsection*{Initialize pool with liquidity}

\begin{itemize}
  \item When initializing a pool, no asset balances can be $0$
  \item Once a pool is initialized between assets $A$ and $B$, the UX disallows
    creating another pool between the same assets
    \todo{@Leo: This has no corresponding test descriptions yet.}
  \item Any user can initialize a pool
\end{itemize}

\subsection*{Swap}

\begin{itemize}
  \item Small swaps create low slippage
  \item If the balances of the two assets in a pool are roughly equal, their
    exchange rate is roughly $1$
  \item Swaps selling $A$ to the pool in exchange for $B$ increase the exchange
    rate $A \rightarrow B$ and decrease the exchange rate $B \rightarrow A$
  \item When performing a swap, the user gets $99.4\%$ of what the invariant
    equation says he should get. $0.3\%$ is put into the admin balances (in the
    datum).
\end{itemize}

\subsection*{Add liquidity}

\begin{itemize}
  \item Any user can add liquidity
  \item When adding liquidity, the user receives all newly minted liquidity
    tokens
  \item When adding liquidity, the total number of liquidity tokens (in the
    pool's datum) is increased by the same amount as the tokens minted
  \item When adding liquidity, the pool's value increases with the liquidity
    provided, and the admin balances increase by $0.3\%$ of the paid assets
  \item No transaction has more than one pool in the outputs\footnote{
      The goal of this rule is to simplify the space of protocol attacks.}
\end{itemize}

\subsection*{Withdraw liquidity}

\begin{itemize}
  \item Any user can withdraw liquidity
  \item When withdrawing liquidity in one asset class, $x \cdot y / L^2$
    increases, where $x$, $y$ and $L$ are calculated pre-fee, and $0.6\%$ of
    $\Delta x$ (or $\Delta y$) is retained in the pool (half for admin fees, the
    other half is left in the pool). In other words, when withdrawing $\Delta L$
    liquidity in asset class $X$, $\Delta x$ is the amount the value in the pool
    (value, not datum) changes.
  \item When creating a new pool and then listing all existing pools, the new
    pool shows up
\end{itemize}

\subsection*{Swaps \& liquidity transactions}

All swaps and liquidity transactions have a rule in common: After any
transaction, $x \cdot y / L^2$ has increased. In that statement:
\begin{itemize}
  \item $x$, $y$ and $L$ before the transaction come from the (non-admin)
    balance of the old pool
  \item After the transaction, $x' = x + \Delta x$, where $\Delta x$ is the
    amount $X$ changed in the value of the pool (value, not balances in the
    datum)
  \item $L' = L + \Delta L$, where $\Delta L$ is the amount of $L$ burned/minted
    in the transaction
\end{itemize}

The other rule that all these transactions have in common, is that non-admin
balances $+$ admin balances is equal to the value in the pool.

\subsection*{Kill pool}

\begin{itemize}
  \item The admin user (i.e. he who can kill pools) is independent of who
    created the pool
  \item The admin user can kill pools
  \item Non-admin users cannot kill pools
  \item A pool that is killed, only supports the ``Withdraw liquidity'' endpoint
\end{itemize}

\subsection*{Collect admin fees}

\begin{itemize}
  \item Admin can collect the admin fees: The value of the pool becomes the
    non-admin part of the old pool, the non-admin part is not changes, the admin
    balances in the pool's datum are set to zero, and the admin part is paid out
    to the admin user's wallet.
  \item Non-admin cannot collect admin fees
\end{itemize}

\subsection*{Pool info}

\begin{itemize}
  \item A list of pools can be queried
  \item When a new pool is initialized, the list of valid pools increases by one
  \item When an invalid pool is created, the list of valid pools increases by
    one
  \item When a pool is updated (kill, swap, add liquidity, withdraw liquidity,
    collect admin fees), the list of valid pools doesn't change
  \item For each valid pool, its pool info can be queried
  \item When a valid pool is updated, its pool info is updated appropriately:
    Killing a pool makes the pool info say it is killed, adding liquidity mints
    the same number of liquidity tokens as are added to the ``total number of
    liquidity tokens minted'' etc.
  \item Each pool is verifiable, i.e. any pool which has been initialized
    appropriately is considered a legitimate pool and vice versa
\end{itemize}

\section{Implementation details}

This section discusses what we need in order to implement the interactions
mentioned above. \\

Firstly, in order to run a DEX based on an automated market model\footnote{
  The automated market model states that rather than having market makers and
  takers, such as is done in stock exchanges, the users will be liquidity
  providers (LPs) and traders. The LPs provide liquidity into a pool in exchange
  for a liquidity token, which is used as a `receipt' of the amount of liquidity
  they provided. Traders can then swap against the pool, according to an
  invariant equation. For example, the initial invariant equation used by
  Danaswap will be $x \cdot y = k^2$, where $L \sim k$. This means that the
  amount $\Delta y$ a trader gets in exchange for adding $\Delta x$ is such that
  $(x + \Delta x) \cdot (y - \Delta y) = k^2 = x \cdot y$. \\

  When providing liquidity, $x \rightarrow x'$ and $y \rightarrow y'$ has the
  effect that $k \rightarrow k'$. The number of liquidity tokens the LP
  receives, $\Delta L$, then follows the rule $\Delta L / L = \Delta k / k$.
}, we need a liquidity token linked to the respective pool to exist. This
association between liquidity token and pool is achieved by encoding the pool
identifier into the token name of the liquidity token. The currency-symbol i.e.
the minting policy's hash is equal for all liquidity tokens, this requires one
common minting policy for all tokens.

Secondly, as in the Cardano Application Template, we want the pools to be
identifiable, traceable and verifiable (valid or not). We achieve this by
minting an NFT to identify each pool. This NFT's minting policy will only pass
when initializing a new pool, and each pool will enforce the NFT not to leave.
Lastly, our protocol consists of a number of scripts whose functionalities are
dependent on each other, where some of those functional dependencies are cyclic.
We model/ lock these functional dependencies using the \textit{Config UTxO}
pattern.

\subsection{Config UTXO}

As mentioned above, our protocol consists of a number of scripts whose
functionalities are dependent on each other, where some of those functional
dependencies are cyclic. A naive solution to model/lock these functional
dependencies would be to make the hash of one script a parameter of the other
script and thus a dependency of the hash of the other scripts. This approach is
difficult to implement, as the relation is cyclic. \\

An alternative solution to this problem is a dedicated on-chain component which
tracks the script hashes involved in the protocol. This pattern is named a
Config UTXO. It is identified by an NFT. Each script is then able refer to the
script hashes in the Config UTXO in order to verify the other scripts. \\

A drawback of the Config UTXO is the greater transaction size and thus higher
transaction fees.
% Note: Mention that we're going to try and avoid this transaction size problem
% where it matters, namely in anything but the Pool ID.
Therefore we make use of an hybrid approach between the naive and Config UTXO.
In our case, the Config UTXO will contain the following data in the datum:
the liquidity token minting policy hash and the pool address validator script hash.
The other hash, namely the pool ID minting policy will be passed as parameters. See Figure \ref{hashGraph}  \\

\begin{figure}
  \scalebox{0.5}{\includegraphics{diagram}}
  \caption{
    In the diagram above blue arrows represent passing hashes by Config UTXO and
    red arrows represent passing hashes by script parameter.
  }
  \label{hashGraph}
\end{figure}

It is important that the parameter sub-graph is acyclic so that the hashes are
resolvable. Likewise it's important that the config UTXO sub-graph only includes
arrows from the pool ID minting policy so that all other interactions can be
performed without the config UTXO. \\

This leaves two remaining notes:
\begin{itemize}
  \item The Config UTXO should never change. This means it should be put at an
    address associated with a script which make any transaction fail.\footnote{
      Note that reference inputs don't require their validator scripts to be
      invoked.}
  \item The config UTXO needs an NFT to distinguish it from any invalid config
    UTXOs. This NFT will be generated through a boilerplate minting policy from
    the Hello Cardano Template.
\end{itemize}

\subsection{Pool ID Minting Policy}

Each pool will be identified by a NFT. This allows anyone to verify that a UTXO
at the pool script address is valid, as well as tracing each pool. This
constitutes structurally the same minting policy as the one in
\href{https://github.com/ArdanaLabs/cardano-app-template/blob/master/onchain/src/HelloDiscovery.hs}{
  Hello Discovery}.
The only distinction with the Hello Discovery minting policy is that the Pool ID
policy will refer to the Danaswap Config UTXO.

\subsection{DEX Pool: Liquidity Token Minting Policy}

The liquidity token minting policy will allow any valid pool\footnote{
  A valid pool is any UTXO at the pool script address which holds an NFT minted
  by the Pool ID minting policy.
} to mint and burn its corresponding liquidity token. The liquidity token
minting policy needs to know which liquidity token belongs to which pool through the
Pool ID (NFT).

\subsection{DEX Pool}

When initializing a pool, $k_0^2 = x_0 \cdot y_0$ where $x_0$ and $y_0$ are the
initial balances of asset classes $X$ and $Y$. The admin user receives $L_0 =
k_0$ liquidity tokens. \\

Each pool datum consists of a number of parts:
\begin{itemize}
  \item Admin fee
  \item Liquidity provider fee
  \item The amount in each asset class ($X$ and $Y$) of collected admin fee.
    These amounts are subtracted from the pool's balances in any calculations
    involving the invariant equation.
  \item The number of liquidity tokens ever minted (minus burned)
  \item A boolean representing the pool's kill switch
\end{itemize}

\subsection{Pool Addresses Validator}

The pool addresses validator controls when pools can be spent.
It is therefore responsible for controlling swaps,
liquidity deposits and withdrawals, pool termination
and admin fee collection.
It is also responsible for ensuring that
pool ID tokens never leave its addresses
because they could then be used to open invalid pools.

To do this it enforces the following:
Note: ``The output pool" refers to
the pool in the outputs which has the same pool id
as the input pool invoking the validator.

\begin{itemize}
	\item The input and output pools are valid
	\item The redeemer is valid
	\item When the redeemer action is Swap:
		\begin{itemize}
			\item The exchange invariant doesn't decrease before fees
			\item The Admin fee is increased by $0.3\%$ of the output
			\item The pool increases by $0.3\%$ of the output
			\item No liquidity tokens are minted
			\item The input and output pools are both live
		\end{itemize}
	\item When the redeemer action is Liquidity
		\begin{itemize}
			\item The liquidity invariant $L^2/k^2$ is non decreasing before fees
			and appropriate fees are paid.
				\todo{how should fees work here?}
			\item The datum correctly reflects the change in issued liquidity
			\item The ``liveness" of the pool is not changed
			\item If the input pool is dead the issued liquidity decreases
			\item If the input pool is dead the withdraw is balanced
		\end{itemize}
	\item When the redeemer action is Kill
		\begin{itemize}
			\item The admin signed the transaction
			\item The output pool is dead
			\item Nothing else is changed in the pool
		\end{itemize}
	\item When The redeemer action is Collect
		\begin{itemize}
			\item The admin fees in the output pool are zero
			\item the non admin fees balance stays the same
			\item the output value remains correct for the datum
			\item At least one admin key signed the tx
		\end{itemize}
\end{itemize}


\subsection{Pool ID minting policy}

The pool ID token is a token used to track pools
and to ensure that the pools the protocol interacts with were opened legitimately.
The pool ID token's minting policy is responsible for ensuring
that it is only minted as part of opening a valid vault.
To do so it should enforce all of the following:

\begin{itemize}
	\item The config UTXO is valid
	\item Exactly one token is minted
	\item That token is sent to a pool
	\item The redeemer provides a seed UTXO
	\item The token name of the minted token is the hash of the seed UTXO
	\item The seed UTXO is spent in the transaction
	\item The output pool datum is valid
	\item The datum correctly reflects the number of liquidity tokens being minted
	\item at least one liquidity token is being minted
	\item the initial invariant is not zero ie. some liquidity is provided in each token
	\item The issued liquidity is exactly the square root of the initial value
\end{itemize}

NOTE: Pools not being duplicates will be checked in the browser app, but not enforced onchain.

\subsection{Liquidity token minting policy}

The liquidity tokens are used to represent ownership of liquidity in a pool.
Their minting policy is responsible for ensuring that they are only minted
during liquidity interactions with a pool and during pool initializations.

Since the Pools Address Validator and the pool ID token minting policy
already enforce the logic regarding how much should be minted the liquidity
token minting policy doesn't have to do much. It's main responsibility is enforcing that
some pool is involved either by being opened or an existing pool being used, and that
the liquidity tokens being created correspond to the pool being used.
The way we keep track of which liquidity tokens correspond to which pools
is by having the token name be the ID of the pool the liquidity tokens
belong to.

To do that it enforces the following:
\begin{itemize}
	\item The liquidity tokens being minted all have the same token name/pool id
	\item The redeemer is valid
		\begin{itemize}
			\item When the redeemer is Initialize: A pool ID token with the same ID is being minted
			\item When the redeemer is Pool: There is an input with a pool ID token with the same id
		\end{itemize}
\end{itemize}

\subsection{Initializing the protocol}

The first step to initialize the protocol, is to mint an NFT, which will be
considered the `master' identifier of the protocol, namely the NFT identifying
the Config UTXO. Next, using the name of this NFT, we can calculate the hash
associated with the three other scripts (pool validator script, liquidity token
minting policy and Pool ID minting policy). Finally, a Config UTXO is
initialized with the `master' NFT and a datum that contains the two hashes, in
that order: Pool script and pool ID script.

\subsection{Off-chain notes}

Initialize pool: Initially, $k_0 = x_0 \cdot y_0$ where $x_0$ and $y_0$ are the
initial amounts. The admin user receives $k_0$ liquidity tokens.

\subsection{Queries}

Pools can be listed by getting all the UTXOs at the pool addresses and filtering
out pools which don't have valid ids. All the pool info for a given pool
can be gotten by looking at the datum and value of the UTXO.

\subsection{Remarks}

\begin{itemize}
  \item The protocol involves a number of equations which must be verified
    on-chain. All on-chain code will exclusively use integers (representing e.g.
    ADA amounts in lovelace, rather than ADA). We must thus define the concept
    of the invariant equation equality a bit more subtly. We propose to do this
    by claiming that $x \cdot y = k^2 \Leftrightarrow (k-1)^2 < x \cdot y <
    (k+1)^2$.
		%% I know the rounding is fairly small and letting users round against the exchange
		%% is not a significant issue but this seems needlessly complicated
		%% compared to the L^2/X*Y invariant solution.
\end{itemize}

\todo{Figure out how rounding should actually be handled, both on-chain and
off-chain.}

\section{Tests}

\todo{List off-chain tests.}

Note: The off-chain tests also check that the on-chain code allows valid
transactions.

\todo{Should we write Apropos-Tx tests?}

\subsection{Config utxo tests}

\subsubsection{NFT}


NFT tests

\begin{itemize}
	\item When minting an NFT with the seed UTxO as an input, validation passes.
	\item When minting an NFT with the seed UTxO as a reference input, validation fails.
	\item When minting an NFT more than once, validation fails.
	\item When burning an NFT, validation fails.
\end{itemize}

\subsubsection{Config UTxO}

\begin{itemize}
	\item When spending the config UTxO, validation fails.
\end{itemize}

\subsection{Liquidity Token Minting Policy tests}

\begin{itemize}
	\item When minting $\sqrt{A_0B_0}$ liquidity tokens on pool open, validation passes.
	\item When minting a different pool's liquidity token on pool open, validation fails.
	\item When minting multiple liquidity token types on pool open, validation fails.
	\item When minting liquidity tokens for a different pool than the pool being spent, validation fails.
	\item When burning liquidity tokens from a different pool than the pool being spent, validation fails.
	\item When minting liquidity tokens for a pool at an address that is not the Pool Address Validator, validation fails.
	\item Given a pool containing total issued liquidity tokens of quantity $t$ of $T$ and asset
	      pair of quantities $a$ of $A$ and $b$ of $B$, when the user provides quantities $\Delta a$ and $\Delta b$
  	      and mints a quantity of liquidity tokens less than or equal to
	      $T \cdot \frac{\sqrt{ (a + \Delta a) \cdot (b + \Delta b)} - \sqrt{a \cdot b}}{\sqrt{a \cdot b}}$
	      , validation passes.
	\item Given a pool containing total issued liquidity tokens of quantity $t$ of $T$ and asset
	      pair of quantities $a$ of $A$ and $b$ of $B$, when the user provides quantities $\Delta a$ and $\Delta b$
	      and mints a quantity of liquidity tokens greater than
              $T \cdot \frac{\sqrt{ (a + \Delta a) \cdot (b + \Delta b)} - \sqrt{a \cdot b}}{\sqrt{a \cdot b}}$
	      , validation fails.
	\item Given a pool containing total issued liquidity tokens of quantity $t$ of $T$ and asset pair of quantities
	      $a$ of $A$ and $b$ of $B$, when the user burns
	      their liquidity token quantity $\Delta t$ and receives a quantity of $A$ less than or equal to
	      $ a \cdot \Delta t/t $ and quantity of $B$ less than or equal to $ a \cdot \delta t/t $
	      , validation passes.
	\item Given a pool containing total issued liquidity tokens of quantity $t$ of $T$ and asset
	      pair of quantities $a$ of $A$ and $b$ of $B$, when the user burns
	      their liquidity token quantity $\Delta t$ and receives a quantity of $A$ greater than
	      $ a \cdot \Delta t/t $ or (||) quantity of token $B$ greater than or equal to $ a \cdot \delta t/t $
	      , validation fails.
\end{itemize}

\subsection{Pool id Token Minting Policy tests}

\begin{itemize}
	\item Non admin can initialize a pool
	\item Can't under pay for liquidity on open
	\item Can't open pool with 0 liquidity
	\item Can't open pool with 0 of either exchange token
		%% This is sorta redundant cause the liquidity needs to be
		%% wrong or 0
	\item A utxo without the config NFT can't be used to open a pool
	\item Can't mint more than 1 token
	\item Can't send identifier token to non-pool address
	\item Can't mint without spending seed Tx
	\item Can't issue more liquidity than datum reflects
	\item Can't mint with liquidity not equal to the initial invariant
	\item Can't remove pool id from address during any type of transaction
	\item Can't kill a pool with a swap
	\item Can't kill a pool with a liquidity change
	\item Can't swap on a dead pool
	\item Can't add liquidity to a dead pool
	\item Can't make unbalanced withdrawals from a dead pool
\end{itemize}

\subsection{Pool Address Validator tests}

\begin{itemize}
	\item can perform valid swaps
	\item can't underpay for swaps
	\item can perform valid liquidity changes
	\item can't perform underpaid liquidity changes
	\item admin can kill a pool
	\item non-admin can't kill a pool
	\item admin can't over extract fees
	\item liquidity can be extracted from a dead pool
	\item Can't steal pool ID tokens (this should consist of tests at each endpoint)
	\item Pool ids can't be swapped between two pools
  \item It shouldn't be possible to add liquidity and then withdraw it in order to essentially swap with
    reduced fees
\end{itemize}

\subsection{Query tests}

The following intended behaviors need to work:
\begin{itemize}
	\item New pools show up in queries
	\item New pools without pool id tokens do not show up in queries
	\todo{Do we need to worry about a large number of invalid pools slowing down
	queries? If so should we add an interaction to remove them?}
	\item Queries accurately reflect how the pool was setup
	\item Queries accurately reflect the change from a swap
	\item Queries accurately reflect liquidity changes
	\item Queries accurately reflect pool kills
	\item A swap in the $A \rightarrow B$ direction increases the price of $B$
	\item Exchange rate query is accurate for small exchanges
\end{itemize}

Additional tests:
\begin{itemize}
	\item When adding liquidity, the number in the pool's datum representing the
    total amount of liquidity minted goes up by the same amount as the actual amount minted
\end{itemize}

Note: We should improve on the template by making better tools for checking that tests fail for the right reason.

\end{document}
